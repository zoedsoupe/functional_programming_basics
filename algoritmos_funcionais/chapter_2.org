#+title: Princ√≠pios Operacionais B√°sicos

* 2.1 Tipos de dados b√°sicos

| Nome              | Descri√ß√£o                             | Haskell                       |
|-------------------+---------------------------------------+-------------------------------|
| n√∫mero            | representa qualquer unidade num√©rica  | Int, Double, ...              |
| l√≥gico            | expressa o conceito l√≥gico matem√°tico | &&, not, \vert \vert          |
| cadeia/carecteres | representa as strings ou Chars        | "" for String and '' for Char |
| lista             | representa uma lista encadeada$       | [<tipo>]                      |
| tupla             | representa uma tupla$2                | (<tipo>)                      |

$ Uma lista √© representada como um conjunto mut√°vel, geralmente homog√™nio. Por ser uma lista encadeada
(Linked List), ela √© dividida em quatro segmentos operacionais:
1. =head= -> formado pelo primeiro elemento da lista (cabe√ßa);
2. =init= -> formado por todos os elementos da lista, com exce√ß√£o do √∫ltimo (arranjo);
3. =tail= -> formado por todos os elementos da lista, com exce√ß√£o do primeiro (cauda);
4. =last= -> formado pelo √∫ltimo elemento da lista (√∫ltimo);

$2 Uma tupla √© representada como um conjunto imut√°vel, geralmente heterog√™nio. √â armazenada
continuamente na mem√≥ria, oferecendo acesso instant√¢neo a qualquer elemento indexado.

* 2.2 Vari√°veis e constantes
Em linguagens funcionais puras (=Haskell=), as vari√°veis tendem a ser imut√°veis, isso significa
que qualquer valor pode ser atribuido a uma vari√°vel, por√©m, ap√≥s a asser√ß√£o do valor,
n√£o ser√° poss√≠vel modificar a vari√°vel.

J√° em linguagens funcionais impuras (=Elixir=), as vari√°veis podem ser "redeclaradas", por√©m nesse caso
em espec√≠fico, se utiliza o conceito de =pattern matching=, significando que a vari√°vel n√£o √© modificada
na mem√≥ria, e sim √© criada uma nova refer√™ncia na mem√≥ria, so√≥ que tendo o mesmo apelido, ou "nome"
da vari√°vel antiga, n√£o produzindo, necessariamente, efeitos colaterais.

As constantes podem ser criadas de forma ~expl√≠ta~ ou ~impl√≠cita~:
- ~expl√≠cita~ -> =a = 2.4=;
- ~impl√≠cita~ -> =ü•ß=;

* 2.3 Operadores
** 2.3.1 Aritm√©ticos
Podem ser divididos em ~un√°rios~, afetando apenas uma entidade, ou ~bin√°rios~, indicando
uma rela√ß√£o entre duas entidades.

- Bin√°rios -> =["asser√ß√£o", "exponencia√ß√£o", "radicia√ß√£o", "multiplica√ß√£o", "divis√£o", "adi√ß√£o", "subtra√ß√£o", "concatena√ß√£o"]=
- Un√°rios -> =["invers√£o positiva", "invers√£o negativa", "retorno de fun√ß√£o"]=

** 2.3.2 Relacionais
Operadores que representam ~express√µes relacionais~

| Operador   | Opera√ß√£o           |
|------------+--------------------|
| >          | maior que          |
| <>         | menor que          |
| >=         | maior ou igual que |
| <=         | menor ou igual que |
| =          | igual a            |
| <>         | diferente de       |

** 2.3.3 L√≥gicos
Operadores que representam ~express√µes l√≥gicas~

| Operador | Opera√ß√£o  |
|----------+-----------|
| .n√£o.    | nega√ß√£o   |
| .e.      | conjun√ß√£o |
| .ou.     | disjun√ß√£o |

*** Tabelas verdade
- Legenda:
  - ~1~ -> =verdadeiro=
  - ~0~ -> =falso=

**** Nega√ß√£o
| Condi√ß√£o | Resultado |
|----------+-----------|
|        0 |         1 |
|        1 |         0 |

**** Conjun√ß√£o
| Condi√ß√£o1 | Condi√ß√£o2 | Resultado |
|-----------+-----------+-----------|
|         0 |         0 |         0 |
|         1 |         0 |         0 |
|         0 |         1 |         0 |
|         1 |         1 |         1 |

**** Disjun√ß√£o
| Condi√ß√£o1 | Condi√ß√£o2 | Resultado |
|-----------+-----------+-----------|
|         0 |         0 |         0 |
|         1 |         0 |         1 |
|         0 |         1 |         1 |
|         1 |         1 |         1 |

* 2.5 Fun√ß√µes e constantes definidas
A representa√ß√£o das fun√ß√µes, tanto quanto suas assinuturas em portugu√™s funcional
ser√£o indicadas como:

- Assinatura -> =<nome_fun√ß√£o> (<argumentos>) >> <tipo_dado>=
- Defini√ß√£o -> =<nome_fun√ß√£o> (argumentos) << <opera√ß√£o>=

Portanto, como exemplo, tenhamos a seguinte defini√ß√£o e assinatura da fun√ß√£o ~soma~:
- Assinatura -> =soma (n√∫mero, n√∫mero) >> n√∫mero=
- Defini√ß√£o -> =soma (valor1, valor2) << valor1 + valor2=

Agora, representando em =Haskell=:
#+begin_src haskell
soma :: (Num a) => a -> a -> a
soma valor1 valor2 = valor1 + valor2

{-
?| soma 7 3
>| 10
-}
#+end_src

Podemos representar constantes da seguinte forma:
#+begin_src haskell
pi :: (Floating a) => a
pi = 3.14159

e :: (Floating a) => a
e = 2.71828
#+end_src

Fun√ß√µes podem ser compostas! Leve em considera√ß√£o a seguinte defini√ß√£o da fun√ß√£o =quadsoma(x,y)=:
#+begin_src
1: quadrado (n√∫mero) >> n√∫mero
2: quadrado (x) << x ^ 2
3: soma (n√∫mero, n√∫mero) >> n√∫mero
4: soma (x, y) << x + y
5: quadsoma (n√∫mero, n√∫mero) >> n√∫mero
6: quadsoma (x, y) << quadrado (soma(x, y))
#+end_src

Com base nisso, podemos definir as fun√ß√µes =lognat= e =logbas=:
#+begin_Src haskell
peso :: (Floating a) => a
peso = 99999999.49

logNat :: (Floating a) => a -> a
logNat x = peso * (x ** (1 / peso) - 1)

logBas :: (Floating a) => a -> a -> a
logBas x b = logNat x / logNat b
#+end_src

* Exerc√≠cios

** 1
#+begin_src haskell
pi :: (Floating a) => a
pi = 3.14159

areaCirc :: (Floating a) => a -> a
areaCirc r = pi * (r ** 2)
#+end_src
** 2
#+begin_src haskell
qSoma :: (Floating a) => a -> a -> a
qSoma x y = (x + y) ** 2
#+end_src
** 3
#+begin_src haskell
pi :: (Floating a) => a
pi = 3.14159

e :: (Floating a) => a
e = 2.71828

piEme :: (Floating a) => a -> a
piEme x = (x * pi) / e
#+end_src
** 4
#+begin_src haskell
suc :: (Integral a) => a -> a
suc x = x + 1
#+end_src
** 5
#+begin_src haskell
c2f :: (Floating a) => a -> a
c2f c = (c * 9 / 5) + 32
#+end_src
** 6
#+begin_src haskell
f2c :: (Floating a) => a -> a
f2c f = (f - 32) * 5 / 9
#+end_src
** 7
#+begin_src haskell
c2k :: (Floating a) => a -> a
c2k c = c + 273.15
#+end_src
** 8
#+begin_src haskell
k2c :: (Floating a) => a -> a
k2c k = k - 273.15
#+end_src
** 9
#+begin_src haskell
m2cm :: (Num a) => a -> a
m2cm m = m * 100
#+end_src
** 10
#+begin_src haskell
eq :: (Eq a) => a -> a -> Bool
eq a b = a == b
#+end_src
** 11
#+begin_src haskell
ant :: (Integral a) => a -> a
ant x = x - 1
#+end_src
** 12
#+begin_src haskell
cub :: (Floating a) => a -> a
cub x = x ** 3
#+end_src
** 13
#+begin_src haskell
k2f :: (Num a) => a -> a
k2f k = (k - 273.15) * 9 / 5 + 32
#+end_src
** 14
#+begin_src haskell
f2k :: (Num a) => a -> a
f2k f = (f - 32) * 5 / 9 + 273.15
#+end_src
** 15
#+begin_src haskell
imc :: (Floating a) => a -> a -> a
imc p a = p / (a ** 2)
#+end_src
** 16
#+begin_src haskell
prod :: (Num a) => a -> a
prod a b = a * b
#+end_src
** 17
#+begin_src haskell
eq1Degree :: (Integral a, Ord a) => a -> a -> a
eq1Degree a b = if a < 1 then error "0" else x
                   where
                     x = div (-(0 - b)) a
#+end_src
** 18
#+begin_src haskell
areaRet :: (Num a) => a -> a
areaRet a b = a * b
#+end_src
